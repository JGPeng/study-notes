# 变量、作用域与内存

## 原始值与引用值

> ECMAScript变量可以包含两种不同类型的数据：原始值和引用值。<b>原始值</b>就是最简单的数据，<b>引用值</b>则是由多个值构成的对象。<br>
6种原始值：Undefined、Null、Boolean、Number、String和Symbol。<br>
在很多语言中，字符串是使用对象表示的，即引用类型，而在ECMAScript中则是值类型。

### 动态属性

引用值可以随时添加、修改和删除其属性和方法。<br>
原始值不能有属性，尽管尝试给原始值添加属性不会报错。<br>
原始类型的初始化可以使用字面量形式，也可以使用new关键字，但是后者会创建一个Object类型的实例，而其行为类似引用值。

### 复制值

原始值复制，相互独立，互不干扰（复制值的副本）。<br>
引用值复制，复制指针，指向同一个对象。

### 传递参数

ECMAScript中所有函数的参数都是按值传递的。传递方式类似复制值。<br>
ECMAScript中函数的参数是局部变量。

### 确定类型

typeof判断原始值很有用，比如<u>字符串、数值、布尔值、Symbol或undefined</u>。但它对引用值的用处不大，比如 null-->'object'  new String('asd')-->'object'。<br>
instanceof根据**原型链**判断引用类型。
```
console.log(person instanceof Object);  // 判断变量person是否为Object
console.log(person instanceof Array);  // 判断变量person是否为Array
console.log(person instanceof RegExp);  // 判断变量person是否为RegExp
```
<br><br>

## 执行上下文与作用域

> 每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在于这个对象上。<br>
函数参数被认为是当前上下文中的变量，因此也跟上下文中的其他变量遵循相同的访问规则。

### 作用域链增强

某些语句会导致在作用域前端临时添加一个上下文，这个上下文在代码执行后会被删除。<br>
通常在 try/catch语句的catch块 、 with语句 会出现这个现象。<br>
对with语句来说，会向作用域链前端添加指定的对象；对catch语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。
```
// with语句：
function buildUrl() {
    let qs = "?debug=true";
    with(location) {
        let url = href + qs;  // location.href + qs
    }
    return url;  // ReferenceError，url被限制在块级作用域
}

// catch语句：
try {
    nonExistentFunction();
} catch (error) {
    console.error(error);
}
```

### 变量声明

#### var
在使用 var 声明变量时，变量会被自动添加到最接近的上下文。<br>
如果变量未经声明就被初始化了，则会被自动添加到全局上下文。<br>
**提升**：var 声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。<br>
声明的提升意味着会输出 undefined 而不是 ReferenceError。<br>
注意：在初始化变量之前一定要先声明变量。在严格模式下，未经声明就初始化变量会报错。<br>

#### let
let 关键字跟 var 很相似，但它的作用域是**块级**的。块级作用域由最近的一对包含**花括号{}**界定。<br>
let 与 var 的另一个不同之处是在同一作用域内不能声明两次。重复的 var 声明会被忽略，而重复的 let 声明会抛出 SyntaxError。<br>
严格来说，let 在JavaScript运行时也会被提升，但由于“**暂时性死区**”的缘故，实际上不能再声明之前使用 let 变量。<br>

#### const
使用 const 声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值。<br>
const 除了要遵循以上规则，其他方面与 let 声明是一样的。<br>
赋值为对象的 const 变量不能再被重新赋值为其他引用值，但对象的键则不受限制。<br>
如果想让整个对象都不能修改，可以使用 **Object.freeze()**。<br>
在全局作用域中，用 let 和 const 声明的全局变量并没有在全局对象中，只是一个块级作用域（Script）中。<br>
注意：如果开发流程并不会因此而受很大影响，就应该尽可能地多使用 const 声明，除非确实需要一个将来会重新赋值的变量。
<br><br>

## 垃圾回收

> JavaScript 通过自动内存管理实现内存分配和限制资源回收。<br>
**基本思路**：确定哪个变量不会再使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行。<br>
垃圾回收程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回收内存。如何标记未使用的变量有不同的实现方式。<br>

### 标记清理

最常用的垃圾回收策略。<br>
当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。当变量离开上下文时，也会被加上离开上下文的标记。<br>
垃圾回收程序运行时，会销毁带有待删除标记的所有值并回收它们的内存。

### 引用计数

思路：对每个值都记录它被引用的次数。<br>
问题：循环引用。

### 内存管理

> 将内存占用量保持在一个较小的值可以让页面性能更好。<br>
如果数据不再必要，那么把它设置为 null，从而释放其引用（即接触引用，适合全局变量和全局对象，因为局部变量在超出作用域后会被自动解除引用）。

1. 通过 const 和 let 声明提升性能：块级作用域可能会更早地让垃圾回收程序介入，尽早回收应该回收的内存。
2. 隐藏类和删除操作：V8 会将创建的对象与隐藏类关联起来，以跟踪它们的属性特征。共享相同隐藏类的对象性能更好，即：
    + 不要动态添加属性，应该在构造函数中一次性声明所有属性。
    + 不要动态删除属性，应该把不想要的属性设置为 null。

3. 内存泄露
    + 意外声明全局变量：
        ```
        function setName() {
            name = 'Gerald';
        }
        ```
    + 定时器的回调通过闭包引用了外部变量：
        ```
        let name = 'Gerald';
        setInterval(() => {
            console.log(name);
        }, 100);
        ```
    + 闭包造成内存泄漏，调用outer()导致分配给name的内存被泄漏：
        ```
        let outer = function() {
            let name = 'gerald';
            return function() {
                return name;
            }
        }
        outer();  // 只要返回的函数存在就不能清理name，因为闭包一直在引用它。
        ```
4. 静态分配与对象池
